<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Scroll Component Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 600px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        /* æ— é™æ»šåŠ¨ç»„ä»¶å®¹å™¨æ ·å¼ */
        infinite-scroll {
            display: block;
            height: 600px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        /* åˆ—è¡¨é¡¹æ ·å¼ */
        .list-item {
            padding: 20px;
            border-bottom: 1px solid #eee;
            animation: fadeIn 0.3s ease;
        }
        
        .list-item:hover {
            background-color: #f8f9fa;
        }
        
        .list-item h3 {
            margin-bottom: 8px;
            color: #333;
        }
        
        .list-item p {
            color: #666;
            line-height: 1.6;
        }
        
        .list-item .meta {
            margin-top: 8px;
            font-size: 14px;
            color: #999;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* æ§åˆ¶æŒ‰é’® */
        .controls {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .controls button {
            padding: 10px 20px;
            margin: 0 5px;
            border: none;
            border-radius: 4px;
            background-color: #3498db;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .controls button:hover {
            background-color: #2980b9;
        }
        
        .controls button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        /* çŠ¶æ€ä¿¡æ¯ */
        .status {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 4px;
            text-align: center;
        }
        
        /* è‡ªå®šä¹‰åŠ è½½æç¤º */
        .custom-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 20px;
            color: #3498db;
        }
        
        .custom-loading .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #3498db;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* è‡ªå®šä¹‰ç»“æŸæç¤º */
        .custom-end {
            padding: 30px;
            color: #999;
            font-size: 14px;
        }
        
        /* è‡ªå®šä¹‰é”™è¯¯æç¤º */
        .custom-error {
            padding: 20px;
            color: #e74c3c;
            background-color: #fee;
            border-radius: 4px;
            margin: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Infinite Scroll Component Demo</h1>
        
        <div class="status">
            å·²åŠ è½½: <span id="loaded-count">0</span> é¡¹ | 
            é¡µç : <span id="current-page">0</span>
        </div>
        
        <div class="controls">
            <button id="reset-btn">é‡ç½®åˆ—è¡¨</button>
            <button id="simulate-error">æ¨¡æ‹Ÿé”™è¯¯</button>
            <button id="scroll-to-top">å›åˆ°é¡¶éƒ¨</button>
        </div>
        
        <infinite-scroll 
            id="scroll-component"
            threshold="100"
            use-observer="true"
            use-scroll="true">
            
            <!-- åˆ—è¡¨å†…å®¹å®¹å™¨ -->
            <div id="list-content"></div>
            
            <!-- è‡ªå®šä¹‰åŠ è½½ä¸­æ’æ§½ -->
            <div slot="loading" class="custom-loading">
                <div class="spinner"></div>
                <span>æ­£åœ¨åŠ è½½æ›´å¤šå†…å®¹...</span>
            </div>
            
            <!-- è‡ªå®šä¹‰ç»“æŸæ’æ§½ -->
            <div slot="end" class="custom-end">
                ğŸ‰ å·²ç»åˆ°åº•äº†ï¼Œæ²¡æœ‰æ›´å¤šå†…å®¹
            </div>
            
            <!-- è‡ªå®šä¹‰é”™è¯¯æ’æ§½ -->
            <div slot="error" class="custom-error">
                âŒ åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•
            </div>
        </infinite-scroll>
    </div>
    
    <!-- å¼•å…¥ç»„ä»¶ -->
    <script src="infinite-scroll.js"></script>
    
    <script>
        // æ¨¡æ‹Ÿæ•°æ®é…ç½®
        const PAGE_SIZE = 10;
        const TOTAL_ITEMS = 50;
        let currentPage = 0;
        let loadedItems = 0;
        
        // è·å–å…ƒç´ 
        const scrollComponent = document.getElementById('scroll-component');
        const listContent = document.getElementById('list-content');
        const loadedCountEl = document.getElementById('loaded-count');
        const currentPageEl = document.getElementById('current-page');
        
        // ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®
        function generateMockData(page, pageSize) {
            const items = [];
            const start = page * pageSize;
            const end = Math.min(start + pageSize, TOTAL_ITEMS);
            
            for (let i = start; i < end; i++) {
                items.push({
                    id: i + 1,
                    title: `æ–‡ç« æ ‡é¢˜ ${i + 1}`,
                    content: `è¿™æ˜¯ç¬¬ ${i + 1} ç¯‡æ–‡ç« çš„å†…å®¹æ‘˜è¦ã€‚è¿™é‡ŒåŒ…å«äº†ä¸€äº›æœ‰è¶£çš„ä¿¡æ¯ï¼Œè®©åˆ—è¡¨çœ‹èµ·æ¥æ›´åŠ çœŸå®ã€‚`,
                    author: ['å¼ ä¸‰', 'æå››', 'ç‹äº”'][Math.floor(Math.random() * 3)],
                    time: new Date(Date.now() - Math.random() * 86400000).toLocaleString()
                });
            }
            
            return items;
        }
        
        // æ¸²æŸ“åˆ—è¡¨é¡¹
        function renderItems(items) {
            const fragment = document.createDocumentFragment();
            
            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.innerHTML = `
                    <h3>${item.title}</h3>
                    <p>${item.content}</p>
                    <div class="meta">
                        <span>ä½œè€…: ${item.author}</span> | 
                        <span>${item.time}</span>
                    </div>
                `;
                fragment.appendChild(div);
            });
            
            listContent.appendChild(fragment);
        }
        
        // åŠ è½½æ›´å¤šæ•°æ®
        async function loadMore() {
            // è®¾ç½®åŠ è½½çŠ¶æ€
            scrollComponent.loading = true;
            
            try {
                // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // æ¨¡æ‹Ÿéšæœºé”™è¯¯ï¼ˆ10%æ¦‚ç‡ï¼‰
                if (Math.random() < 0.1 && currentPage > 0) {
                    throw new Error('Network error');
                }
                
                // è·å–æ•°æ®
                const items = generateMockData(currentPage, PAGE_SIZE);
                
                if (items.length > 0) {
                    renderItems(items);
                    currentPage++;
                    loadedItems += items.length;
                    
                    // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                    loadedCountEl.textContent = loadedItems;
                    currentPageEl.textContent = currentPage;
                    
                    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ›´å¤š
                    if (loadedItems >= TOTAL_ITEMS) {
                        scrollComponent.hasMore = false;
                    }
                }
                
                // éšè—é”™è¯¯æç¤ºï¼ˆå¦‚æœæœ‰ï¼‰
                scrollComponent.hideError();
                
            } catch (error) {
                console.error('åŠ è½½å¤±è´¥:', error);
                scrollComponent.showError();
            } finally {
                // æ¸…é™¤åŠ è½½çŠ¶æ€
                scrollComponent.loading = false;
            }
        }
        
        // é‡ç½®åˆ—è¡¨
        function resetList() {
            listContent.innerHTML = '';
            currentPage = 0;
            loadedItems = 0;
            loadedCountEl.textContent = '0';
            currentPageEl.textContent = '0';
            scrollComponent.reset();
            
            // åŠ è½½ç¬¬ä¸€é¡µ
            loadMore();
        }
        
        // ç›‘å¬åŠ è½½äº‹ä»¶
        scrollComponent.addEventListener('load', (e) => {
            console.log('è§¦å‘åŠ è½½äº‹ä»¶:', e.detail);
            loadMore();
        });
        
        // ç»‘å®šæŒ‰é’®äº‹ä»¶
        document.getElementById('reset-btn').addEventListener('click', resetList);
        
        document.getElementById('simulate-error').addEventListener('click', () => {
            scrollComponent.showError();
        });
        
        document.getElementById('scroll-to-top').addEventListener('click', () => {
            scrollComponent.scrollToTop();
        });
        
        // åˆå§‹åŠ è½½
        loadMore();
    </script>
</body>
</html>
